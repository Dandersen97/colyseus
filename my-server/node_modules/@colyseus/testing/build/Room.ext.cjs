"use strict";

// packages/testing/src/Room.ext.ts
var import_core = require("@colyseus/core");
var import_sdk = require("@colyseus/sdk");
var _originalOnMessage = import_core.Room.prototype["_onMessage"];
import_core.Room.prototype["_onMessage"] = function() {
  _originalOnMessage.apply(this, arguments);
  if (this._waitingForMessage) {
    setTimeout(() => this._waitingForMessage[1].resolve(), this._waitingForMessage[0]);
  }
};
import_core.Room.prototype.waitForNextMessage = async function(additionalDelay = 0) {
  this._waitingForMessage = [additionalDelay, new import_core.Deferred()];
  return this._waitingForMessage[1];
};
import_core.Room.prototype.waitForMessage = async function(type, rejectTimeout = 3e3) {
  const originalHandlers = this["onMessageEvents"].events[type] || [];
  const room = this;
  return new Promise((resolve, reject) => {
    const rejectionTimeout = setTimeout(() => reject(new Error(`message '${type}' was not called. timed out (${rejectTimeout}ms)`)), rejectTimeout);
    room["onMessageEvents"].events[type] = [
      async function(client, message) {
        clearTimeout(rejectionTimeout);
        for (const handler of originalHandlers) {
          await handler.call(room, client, message);
        }
        room["onMessageEvents"].events[type] = originalHandlers;
        resolve([client, message]);
      }
    ];
  });
};
import_core.Room.prototype.waitForNextSimulationTick = async function() {
  if (this["_simulationInterval"]) {
    const milliseconds = this["_simulationInterval"]["_idleTimeout"];
    return new Promise((resolve) => setTimeout(resolve, milliseconds));
  } else {
    console.warn("\u26A0\uFE0F waitForSimulation() - .setSimulationInterval() is a must.");
    return Promise.resolve();
  }
};
var _originalBroadcastPatch = import_core.Room.prototype["broadcastPatch"];
import_core.Room.prototype["broadcastPatch"] = function() {
  const retVal = _originalBroadcastPatch.call(this);
  if (this._waitingForPatch) {
    setTimeout(() => this._waitingForPatch[1].resolve(), this._waitingForPatch[0]);
  }
  return retVal;
};
import_core.Room.prototype.waitForNextPatch = async function(additionalDelay = 0) {
  this._waitingForPatch = [additionalDelay, new import_core.Deferred()];
  return this._waitingForPatch[1];
};
import_sdk.Room.prototype.waitForMessage = async function(type, rejectTimeout = 3e3) {
  return new Promise((resolve, reject) => {
    const received = (message) => {
      unbind();
      resolve(message);
      clearTimeout(rejectionTimeout);
    };
    const unbind = this["onMessageHandlers"].on(type, (message) => received(message));
    const rejectionTimeout = setTimeout(() => {
      unbind();
      reject(new Error(`message '${type}' was not called. timed out (${rejectTimeout}ms)`));
    }, rejectTimeout);
  });
};
var _originalClientOnMessage = import_sdk.Room.prototype["dispatchMessage"];
import_sdk.Room.prototype["dispatchMessage"] = function() {
  _originalClientOnMessage.apply(this, arguments);
  if (this._waitingForMessage) {
    setTimeout(() => {
      this._waitingForMessage[1].resolve([arguments[0], arguments[1]]);
    }, this._waitingForMessage[0]);
  }
};
import_sdk.Room.prototype.waitForNextMessage = async function(additionalDelay = 0) {
  this._waitingForMessage = [additionalDelay, new import_core.Deferred()];
  return this._waitingForMessage[1];
};
var _originalClientPatch = import_sdk.Room.prototype["patch"];
import_sdk.Room.prototype["patch"] = function() {
  _originalClientPatch.apply(this, arguments);
  if (this._waitingForPatch) {
    setTimeout(() => {
      this._waitingForPatch[1].resolve([arguments[0], arguments[1]]);
    }, this._waitingForPatch[0]);
  }
};
import_sdk.Room.prototype.waitForNextPatch = async function(additionalDelay = 0) {
  this._waitingForPatch = [additionalDelay, new import_core.Deferred()];
  return this._waitingForPatch[1];
};
