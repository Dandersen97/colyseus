import type { Router, HasRequiredKeys, Prettify, UnionToIntersection, Endpoint, HTTPMethod } from "@colyseus/better-call";
import { ColyseusSDK } from "./Client.ts";
/**
 * TODO: we should clean up the types repetition in this file.
 */
type IsAny<T> = 0 extends 1 & T ? true : false;
type IsAnyOrAnyIndexed<T> = IsAny<T> extends true ? true : (string extends keyof T ? true : (number extends keyof T ? (symbol extends keyof T ? true : false) : false));
type HasRequired<T extends {
    body?: any;
    query?: any;
    params?: any;
}> = T["body"] extends object ? HasRequiredKeys<T["body"]> extends true ? true : T["query"] extends object ? HasRequiredKeys<T["query"]> extends true ? true : T["params"] extends object ? HasRequiredKeys<T["params"]> : false : T["params"] extends object ? HasRequiredKeys<T["params"]> : false : T["query"] extends object ? HasRequiredKeys<T["query"]> extends true ? true : T["params"] extends object ? HasRequiredKeys<T["params"]> : false : T["params"] extends object ? HasRequiredKeys<T["params"]> : false;
type InferContext<T> = T extends (ctx: infer Ctx) => any ? Ctx extends object ? Ctx : never : never;
type WithRequired<T, K extends keyof any> = Prettify<T & {
    [P in K & keyof T]-?: NonNullable<T[P]>;
}>;
type WithoutServerOnly<T extends Record<string, Endpoint>> = {
    [K in keyof T]: T[K] extends Endpoint<any, infer O> ? O extends {
        metadata: {
            SERVER_ONLY: true;
        };
    } ? never : T[K] : T[K];
};
type MethodOptions<API, M extends HTTPMethod> = API extends {
    [key: string]: infer T;
} ? T extends Endpoint<any, infer O> ? O["method"] extends M ? {
    [key in T["path"]]: T;
} : O["method"] extends M[] ? M extends O["method"][number] ? {
    [key in T["path"]]: T;
} : {} : O["method"] extends "*" ? {
    [key in T["path"]]: T;
} : {} : {} : {};
export type RequiredOptionKeys<C extends {
    body?: any;
    query?: any;
    params?: any;
}> = (C["body"] extends object ? HasRequiredKeys<C["body"]> extends true ? {
    body: true;
} : {} : {}) & (C["query"] extends object ? HasRequiredKeys<C["query"]> extends true ? {
    query: true;
} : {} : {}) & (C["params"] extends object ? HasRequiredKeys<C["params"]> extends true ? {
    params: true;
} : {} : {});
type CommonHeaders = {
    accept: "application/json" | "text/plain" | "application/octet-stream";
    "content-type": "application/json" | "text/plain" | "application/x-www-form-urlencoded" | "multipart/form-data" | "application/octet-stream";
    authorization: "Bearer" | "Basic";
};
type FetchRequestOptions<Body = any, Query extends Record<string, any> = any, Params extends Record<string, any> | Array<string> | undefined = any, Res = any, ExtraOptions extends Record<string, any> = {}> = Prettify<ExtraOptions & Omit<RequestInit, "body"> & {
    /**
     * Headers
     */
    headers?: CommonHeaders | Headers | HeadersInit;
    /**
     * Body
     */
    body?: Body;
    /**
     * Query parameters (key-value pairs)
     */
    query?: Query;
    /**
     * Dynamic parameters.
     *
     * If url is defined as /path/:id, params will be { id: string }
     */
    params?: Params;
}>;
type FetchResponse<T> = {
    raw: Response;
    data: T;
    headers: Headers;
    status: number;
    statusText: string;
};
export declare function isJSONSerializable(value: any): boolean;
export type ResponseType = "json" | "text" | "blob";
export declare function detectResponseType(request: Response): ResponseType;
type InferredAPI<R> = R extends {
    endpoints: Record<string, Endpoint>;
} ? WithoutServerOnly<R["endpoints"]> : WithoutServerOnly<R & Record<string, Endpoint>>;
type InferReturnType<R, OPT, K extends keyof OPT> = IsAnyOrAnyIndexed<R> extends true ? any : Awaited<ReturnType<OPT[K] extends Endpoint ? OPT[K] : never>>;
export declare class HTTP<R extends Router | Router["endpoints"]> {
    authToken: string | undefined;
    options: FetchRequestOptions;
    private sdk;
    del: {
        <API extends InferredAPI<R> = InferredAPI<R>, OPT extends Prettify<UnionToIntersection<MethodOptions<API, "DELETE">>> = UnionToIntersection<MethodOptions<API, "DELETE">> extends infer T ? { [K_1 in keyof T]: T[K_1]; } : never, K extends keyof OPT = keyof OPT, C extends InferContext<OPT[K]> = InferContext<OPT[K]>>(path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends true ? K : never), options: IsAnyOrAnyIndexed<R> extends true ? FetchRequestOptions<any, any, any> : WithRequired<FetchRequestOptions<C["body"], C["query"], C["params"]>, keyof RequiredOptionKeys<C>>): Promise<FetchResponse<InferReturnType<R, OPT, K>>>;
        <API extends InferredAPI<R> = InferredAPI<R>, OPT extends Prettify<UnionToIntersection<MethodOptions<API, "DELETE">>> = UnionToIntersection<MethodOptions<API, "DELETE">> extends infer T ? { [K_1 in keyof T]: T[K_1]; } : never, K extends keyof OPT = keyof OPT, C extends InferContext<OPT[K]> = InferContext<OPT[K]>>(path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends false ? K : never), options?: IsAnyOrAnyIndexed<R> extends true ? FetchRequestOptions<any, any, any> : FetchRequestOptions<C["body"], C["query"], C["params"]>): Promise<FetchResponse<InferReturnType<R, OPT, K>>>;
    };
    constructor(sdk: ColyseusSDK, baseOptions: FetchRequestOptions);
    private request;
    get<API extends InferredAPI<R> = InferredAPI<R>, OPT extends Prettify<UnionToIntersection<MethodOptions<API, "GET">>> = Prettify<UnionToIntersection<MethodOptions<API, "GET">>>, K extends keyof OPT = keyof OPT, C extends InferContext<OPT[K]> = InferContext<OPT[K]>>(path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends true ? K : never), options: IsAnyOrAnyIndexed<R> extends true ? FetchRequestOptions<any, any, any> : WithRequired<FetchRequestOptions<C["body"], C["query"], C["params"]>, keyof RequiredOptionKeys<C>>): Promise<FetchResponse<InferReturnType<R, OPT, K>>>;
    get<API extends InferredAPI<R> = InferredAPI<R>, OPT extends Prettify<UnionToIntersection<MethodOptions<API, "GET">>> = Prettify<UnionToIntersection<MethodOptions<API, "GET">>>, K extends keyof OPT = keyof OPT, C extends InferContext<OPT[K]> = InferContext<OPT[K]>>(path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends false ? K : never), options?: IsAnyOrAnyIndexed<R> extends true ? FetchRequestOptions<any, any, any> : FetchRequestOptions<C["body"], C["query"], C["params"]>): Promise<FetchResponse<InferReturnType<R, OPT, K>>>;
    post<API extends InferredAPI<R> = InferredAPI<R>, OPT extends Prettify<UnionToIntersection<MethodOptions<API, "POST">>> = Prettify<UnionToIntersection<MethodOptions<API, "POST">>>, K extends keyof OPT = keyof OPT, C extends InferContext<OPT[K]> = InferContext<OPT[K]>>(path: (IsAnyOrAnyIndexed<R> extends true ? string : never) | (IsAny<API> extends true ? string : never) | (HasRequired<C> extends true ? K : never), options: IsAnyOrAnyIndexed<R> extends true ? FetchRequestOptions<any, any, any> : (IsAny<API> extends true ? FetchRequestOptions<any, any, any> : WithRequired<FetchRequestOptions<C["body"], C["query"], C["params"]>, keyof RequiredOptionKeys<C>>)): Promise<FetchResponse<InferReturnType<R, OPT, K>>>;
    post<API extends InferredAPI<R> = InferredAPI<R>, OPT extends Prettify<UnionToIntersection<MethodOptions<API, "POST">>> = Prettify<UnionToIntersection<MethodOptions<API, "POST">>>, K extends keyof OPT = keyof OPT, C extends InferContext<OPT[K]> = InferContext<OPT[K]>>(path: (IsAnyOrAnyIndexed<R> extends true ? string : never) | (IsAny<API> extends true ? string : never) | (HasRequired<C> extends false ? K : never), options?: IsAnyOrAnyIndexed<R> extends true ? FetchRequestOptions<any, any, any> : (IsAny<API> extends true ? FetchRequestOptions<any, any, any> : FetchRequestOptions<C["body"], C["query"], C["params"]>)): Promise<FetchResponse<InferReturnType<R, OPT, K>>>;
    delete<API extends InferredAPI<R> = InferredAPI<R>, OPT extends Prettify<UnionToIntersection<MethodOptions<API, "DELETE">>> = Prettify<UnionToIntersection<MethodOptions<API, "DELETE">>>, K extends keyof OPT = keyof OPT, C extends InferContext<OPT[K]> = InferContext<OPT[K]>>(path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends true ? K : never), options: IsAnyOrAnyIndexed<R> extends true ? FetchRequestOptions<any, any, any> : WithRequired<FetchRequestOptions<C["body"], C["query"], C["params"]>, keyof RequiredOptionKeys<C>>): Promise<FetchResponse<InferReturnType<R, OPT, K>>>;
    delete<API extends InferredAPI<R> = InferredAPI<R>, OPT extends Prettify<UnionToIntersection<MethodOptions<API, "DELETE">>> = Prettify<UnionToIntersection<MethodOptions<API, "DELETE">>>, K extends keyof OPT = keyof OPT, C extends InferContext<OPT[K]> = InferContext<OPT[K]>>(path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends false ? K : never), options?: IsAnyOrAnyIndexed<R> extends true ? FetchRequestOptions<any, any, any> : FetchRequestOptions<C["body"], C["query"], C["params"]>): Promise<FetchResponse<InferReturnType<R, OPT, K>>>;
    patch<API extends InferredAPI<R> = InferredAPI<R>, OPT extends Prettify<UnionToIntersection<MethodOptions<API, "PATCH">>> = Prettify<UnionToIntersection<MethodOptions<API, "PATCH">>>, K extends keyof OPT = keyof OPT, C extends InferContext<OPT[K]> = InferContext<OPT[K]>>(path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends true ? K : never), options: IsAnyOrAnyIndexed<R> extends true ? FetchRequestOptions<any, any, any> : WithRequired<FetchRequestOptions<C["body"], C["query"], C["params"]>, keyof RequiredOptionKeys<C>>): Promise<FetchResponse<InferReturnType<R, OPT, K>>>;
    patch<API extends InferredAPI<R> = InferredAPI<R>, OPT extends Prettify<UnionToIntersection<MethodOptions<API, "PATCH">>> = Prettify<UnionToIntersection<MethodOptions<API, "PATCH">>>, K extends keyof OPT = keyof OPT, C extends InferContext<OPT[K]> = InferContext<OPT[K]>>(path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends false ? K : never), options?: IsAnyOrAnyIndexed<R> extends true ? FetchRequestOptions<any, any, any> : FetchRequestOptions<C["body"], C["query"], C["params"]>): Promise<FetchResponse<InferReturnType<R, OPT, K>>>;
    put<API extends InferredAPI<R> = InferredAPI<R>, OPT extends Prettify<UnionToIntersection<MethodOptions<API, "PUT">>> = Prettify<UnionToIntersection<MethodOptions<API, "PUT">>>, K extends keyof OPT = keyof OPT, C extends InferContext<OPT[K]> = InferContext<OPT[K]>>(path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends true ? K : never), options: IsAnyOrAnyIndexed<R> extends true ? FetchRequestOptions<any, any, any> : WithRequired<FetchRequestOptions<C["body"], C["query"], C["params"]>, keyof RequiredOptionKeys<C>>): Promise<FetchResponse<InferReturnType<R, OPT, K>>>;
    put<API extends InferredAPI<R> = InferredAPI<R>, OPT extends Prettify<UnionToIntersection<MethodOptions<API, "PUT">>> = Prettify<UnionToIntersection<MethodOptions<API, "PUT">>>, K extends keyof OPT = keyof OPT, C extends InferContext<OPT[K]> = InferContext<OPT[K]>>(path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends false ? K : never), options?: IsAnyOrAnyIndexed<R> extends true ? FetchRequestOptions<any, any, any> : FetchRequestOptions<C["body"], C["query"], C["params"]>): Promise<FetchResponse<InferReturnType<R, OPT, K>>>;
    protected executeRequest<M extends HTTPMethod>(method: M, path: any, requestOptions?: any): Promise<any>;
}
export {};
