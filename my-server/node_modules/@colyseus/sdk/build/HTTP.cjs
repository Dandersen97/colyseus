// Copyright (c) 2026 Endel Dreyer.
//
// This software is released under the MIT License.
// https://opensource.org/license/MIT
//
// colyseus.js@0.17.29
'use strict';

var tslib = require('tslib');
var Errors = require('./errors/Errors.cjs');

function isJSONSerializable(value) {
    if (value === undefined) {
        return false;
    }
    const t = typeof value;
    if (t === "string" || t === "number" || t === "boolean" || t === null) {
        return true;
    }
    if (t !== "object") {
        return false;
    }
    if (Array.isArray(value)) {
        return true;
    }
    if (value.buffer) {
        return false;
    }
    return ((value.constructor && value.constructor.name === "Object") ||
        typeof value.toJSON === "function");
}
const JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(request) {
    const _contentType = request.headers.get("content-type");
    const textTypes = new Set([
        "image/svg",
        "application/xml",
        "application/xhtml",
        "application/html",
    ]);
    if (!_contentType) {
        return "json";
    }
    const contentType = _contentType.split(";").shift() || "";
    if (JSON_RE.test(contentType)) {
        return "json";
    }
    if (textTypes.has(contentType) || contentType.startsWith("text/")) {
        return "text";
    }
    return "blob";
}
function getURLWithQueryParams(url, option) {
    const { params, query } = option || {};
    // Parse the URL and extract existing query parameters
    const [urlPath, urlQuery] = url.split("?");
    let path = urlPath;
    // Handle params substitution
    if (params) {
        if (Array.isArray(params)) {
            const paramPaths = path.split("/").filter((p) => p.startsWith(":"));
            for (const [index, key] of paramPaths.entries()) {
                const value = params[index];
                path = path.replace(key, value);
            }
        }
        else {
            for (const [key, value] of Object.entries(params)) {
                path = path.replace(`:${key}`, String(value));
            }
        }
    }
    // Merge query parameters from URL and options
    const queryParams = new URLSearchParams(urlQuery);
    if (query) {
        for (const [key, value] of Object.entries(query)) {
            if (value == null)
                continue;
            queryParams.set(key, String(value));
        }
    }
    // Build final URL
    let queryParamString = queryParams.toString();
    queryParamString = queryParamString.length > 0 ? `?${queryParamString}`.replace(/\+/g, "%20") : "";
    return `${path}${queryParamString}`;
}
class HTTP {
    constructor(sdk, baseOptions) {
        // alias "del()" to "delete()"
        this.del = this.delete;
        this.sdk = sdk;
        this.options = baseOptions;
    }
    request(method, path, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.executeRequest(method, path, options);
        });
    }
    get(path, options) {
        return this.request("GET", path, options);
    }
    post(path, options) {
        return this.request("POST", path, options);
    }
    delete(path, options) {
        return this.request("DELETE", path, options);
    }
    patch(path, options) {
        return this.request("PATCH", path, options);
    }
    put(path, options) {
        return this.request("PUT", path, options);
    }
    executeRequest(method, path, requestOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            //
            // FIXME: if FormData is provided, merging "baseOptions.body" with
            // "options.body" will not work as intended
            //
            let body = (this.options.body)
                ? Object.assign(Object.assign({}, this.options.body), ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.body) || {})) : requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.body;
            const query = (this.options.query)
                ? Object.assign(Object.assign({}, this.options.query), ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.query) || {})) : requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.query;
            const params = (this.options.params)
                ? Object.assign(Object.assign({}, this.options.params), ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.params) || {})) : requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.params;
            const headers = new Headers((this.options.headers)
                ? Object.assign(Object.assign({}, this.options.headers), ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers) || {})) : requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            // Add Authorization header if authToken is set
            if (this.authToken && !headers.has("authorization")) {
                headers.set("authorization", `Bearer ${this.authToken}`);
            }
            // Stringify JSON-serializable objects for fetch() body
            if (isJSONSerializable(body) && typeof body === 'object' && body !== null) {
                if (!headers.has("content-type")) {
                    headers.set("content-type", "application/json");
                }
                for (const [key, value] of Object.entries(body)) {
                    if (value instanceof Date) {
                        body[key] = value.toISOString();
                    }
                }
                body = JSON.stringify(body);
            }
            const mergedOptions = Object.assign(Object.assign(Object.assign({ credentials: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.credentials) || "include" }, this.options), requestOptions), { query,
                params,
                headers,
                body,
                method });
            const url = getURLWithQueryParams(this.sdk['getHttpEndpoint'](path.toString()), mergedOptions);
            let raw;
            try {
                raw = yield fetch(url, mergedOptions);
            }
            catch (err) {
                // If it's an AbortError, re-throw as-is
                if (err.name === 'AbortError') {
                    throw err;
                }
                // Re-throw with network error code at top level (e.g. ECONNREFUSED)
                const networkError = new Errors.ServerError(((_a = err.cause) === null || _a === void 0 ? void 0 : _a.code) || err.code, err.message);
                networkError.response = raw;
                networkError.cause = err.cause;
                throw networkError;
            }
            const contentType = raw.headers.get("content-type");
            let data;
            // TODO: improve content-type detection here!
            if (contentType === null || contentType === void 0 ? void 0 : contentType.indexOf("json")) {
                data = yield raw.json();
            }
            else if (contentType === null || contentType === void 0 ? void 0 : contentType.indexOf("text")) {
                data = yield raw.text();
            }
            else {
                data = yield raw.blob();
            }
            if (!raw.ok) {
                throw new Errors.ServerError((_b = data.code) !== null && _b !== void 0 ? _b : raw.status, (_d = (_c = data.error) !== null && _c !== void 0 ? _c : data.message) !== null && _d !== void 0 ? _d : raw.statusText, {
                    headers: raw.headers,
                    status: raw.status,
                    response: raw,
                    data
                });
            }
            return {
                raw,
                data,
                headers: raw.headers,
                status: raw.status,
                statusText: raw.statusText,
            };
        });
    }
}

exports.HTTP = HTTP;
exports.detectResponseType = detectResponseType;
exports.isJSONSerializable = isJSONSerializable;
//# sourceMappingURL=HTTP.cjs.map
