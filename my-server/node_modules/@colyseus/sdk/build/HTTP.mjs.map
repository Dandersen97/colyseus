{"version":3,"file":"HTTP.mjs","sources":["../src/HTTP.ts"],"sourcesContent":["import type { Router, HasRequiredKeys, Prettify, UnionToIntersection, Endpoint, HTTPMethod } from \"@colyseus/better-call\";\nimport { ColyseusSDK } from \"./Client.ts\";\nimport { ServerError } from \"./errors/Errors.ts\";\n\n/**\n * TODO: we should clean up the types repetition in this file.\n */\n\n// Helper to check if a type is 'any'\ntype IsAny<T> = 0 extends 1 & T ? true : false;\n\n// Helper to check if a type resolves to any after indexed access\n// When T is any, T[K] is also any, but IsAny<T[K]> may not detect it due to deferred evaluation\n// We check multiple characteristics of 'any':\n// 1. Direct any check: IsAny<T>\n// 2. Accepts all string keys: string extends keyof T\n// 3. Accepts all number and symbol keys: for complete 'any' detection\ntype IsAnyOrAnyIndexed<T> = IsAny<T> extends true\n    ? true\n    : (string extends keyof T\n        ? true\n        : (number extends keyof T\n            ? (symbol extends keyof T ? true : false)\n            : false));\n\ntype HasRequired<\n    T extends {\n        body?: any;\n        query?: any;\n        params?: any;\n    },\n> = T[\"body\"] extends object\n    ? HasRequiredKeys<T[\"body\"]> extends true\n        ? true\n        : T[\"query\"] extends object\n            ? HasRequiredKeys<T[\"query\"]> extends true\n                ? true\n                : T[\"params\"] extends object\n                    ? HasRequiredKeys<T[\"params\"]>\n                    : false\n            : T[\"params\"] extends object\n                ? HasRequiredKeys<T[\"params\"]>\n                : false\n    : T[\"query\"] extends object\n        ? HasRequiredKeys<T[\"query\"]> extends true\n            ? true\n            : T[\"params\"] extends object\n                ? HasRequiredKeys<T[\"params\"]>\n                : false\n        : T[\"params\"] extends object\n            ? HasRequiredKeys<T[\"params\"]>\n            : false;\n\ntype InferContext<T> = T extends (ctx: infer Ctx) => any\n    ? Ctx extends object\n        ? Ctx\n        : never\n    : never;\n\n// WithRequired - makes specific keys required\n// This works by spreading T and then overriding the specified keys to be non-nullable\ntype WithRequired<T, K extends keyof any> = Prettify<T & {\n    [P in K & keyof T]-?: NonNullable<T[P]>\n}>;\n\ntype WithoutServerOnly<T extends Record<string, Endpoint>> = {\n    [K in keyof T]: T[K] extends Endpoint<any, infer O>\n        ? O extends { metadata: { SERVER_ONLY: true } }\n            ? never\n            : T[K]\n        : T[K];\n};\n\n// Method-specific options type\ntype MethodOptions<API, M extends HTTPMethod> = API extends { [key: string]: infer T; }\n    ? T extends Endpoint<any, infer O>\n        ? O[\"method\"] extends M\n            ? { [key in T[\"path\"]]: T; }\n            : O[\"method\"] extends M[]\n                ? M extends O[\"method\"][number]\n                    ? { [key in T[\"path\"]]: T; }\n                    : {}\n                : O[\"method\"] extends \"*\"\n                    ? { [key in T[\"path\"]]: T; }\n                    : {}\n        : {}\n    : {};\n\nexport type RequiredOptionKeys<\n    C extends {\n        body?: any;\n        query?: any;\n        params?: any;\n    },\n> = (C[\"body\"] extends object\n    ? HasRequiredKeys<C[\"body\"]> extends true\n        ? { body: true }\n        : {}\n    : {}) &\n    (C[\"query\"] extends object\n        ? HasRequiredKeys<C[\"query\"]> extends true\n            ? { query: true }\n            : {}\n        : {}) &\n    (C[\"params\"] extends object\n        ? HasRequiredKeys<C[\"params\"]> extends true\n            ? { params: true }\n            : {}\n        : {});\n\n\ntype CommonHeaders = {\n    accept: \"application/json\" | \"text/plain\" | \"application/octet-stream\";\n    \"content-type\": \"application/json\" | \"text/plain\" | \"application/x-www-form-urlencoded\" | \"multipart/form-data\" | \"application/octet-stream\";\n    authorization: \"Bearer\" | \"Basic\";\n};\n\ntype FetchRequestOptions<\n  Body = any,\n  Query extends Record<string, any> = any,\n  Params extends Record<string, any> | Array<string> | undefined = any, Res = any,\n  ExtraOptions extends Record<string, any> = {}\n> = Prettify<ExtraOptions & Omit<RequestInit, \"body\"> & {\n//   baseURL?: string;\n\n  /**\n   * Headers\n   */\n  headers?: CommonHeaders | Headers | HeadersInit;\n\n  /**\n   * Body\n   */\n  body?: Body;\n\n  /**\n   * Query parameters (key-value pairs)\n   */\n  query?: Query;\n\n  /**\n   * Dynamic parameters.\n   *\n   * If url is defined as /path/:id, params will be { id: string }\n   */\n  params?: Params;\n}>\n\ntype FetchResponse<T> = {\n  raw: Response;\n  data: T;\n  headers: Headers;\n  status: number;\n  statusText: string;\n};\n\nexport function isJSONSerializable(value: any) {\n\tif (value === undefined) {\n\t\treturn false;\n\t}\n\tconst t = typeof value;\n\tif (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n\t\treturn true;\n\t}\n\tif (t !== \"object\") {\n\t\treturn false;\n\t}\n\tif (Array.isArray(value)) {\n\t\treturn true;\n\t}\n\tif (value.buffer) {\n\t\treturn false;\n\t}\n\treturn (\n\t\t(value.constructor && value.constructor.name === \"Object\") ||\n\t\ttypeof value.toJSON === \"function\"\n\t);\n}\n\nconst JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\n\nexport type ResponseType = \"json\" | \"text\" | \"blob\";\nexport function detectResponseType(request: Response): ResponseType {\n\tconst _contentType = request.headers.get(\"content-type\");\n\tconst textTypes = new Set([\n\t\t\"image/svg\",\n\t\t\"application/xml\",\n\t\t\"application/xhtml\",\n\t\t\"application/html\",\n\t]);\n\tif (!_contentType) {\n\t\treturn \"json\";\n\t}\n\tconst contentType = _contentType.split(\";\").shift() || \"\";\n\tif (JSON_RE.test(contentType)) {\n\t\treturn \"json\";\n\t}\n\tif (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n\t\treturn \"text\";\n\t}\n\treturn \"blob\";\n}\n\nfunction getURLWithQueryParams(url: string, option?: FetchRequestOptions) {\n\tconst { params, query } = option || {};\n\n\t// Parse the URL and extract existing query parameters\n\tconst [urlPath, urlQuery] = url.split(\"?\");\n\tlet path = urlPath;\n\n\t// Handle params substitution\n\tif (params) {\n\t\tif (Array.isArray(params)) {\n\t\t\tconst paramPaths = path.split(\"/\").filter((p) => p.startsWith(\":\"));\n\t\t\tfor (const [index, key] of paramPaths.entries()) {\n\t\t\t\tconst value = params[index];\n\t\t\t\tpath = path.replace(key, value);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const [key, value] of Object.entries(params)) {\n\t\t\t\tpath = path.replace(`:${key}`, String(value));\n\t\t\t}\n\t\t}\n\t}\n\n\t// Merge query parameters from URL and options\n\tconst queryParams = new URLSearchParams(urlQuery);\n\tif (query) {\n\t\tfor (const [key, value] of Object.entries(query)) {\n\t\t\tif (value == null) continue;\n\t\t\tqueryParams.set(key, String(value));\n\t\t}\n\t}\n\n\t// Build final URL\n\tlet queryParamString = queryParams.toString();\n\tqueryParamString = queryParamString.length > 0 ? `?${queryParamString}`.replace(/\\+/g, \"%20\") : \"\";\n\n\treturn `${path}${queryParamString}`;\n}\n\ntype InferredAPI<R> = R extends { endpoints: Record<string, Endpoint> }\n    ? WithoutServerOnly<R[\"endpoints\"]>\n    : WithoutServerOnly<R & Record<string, Endpoint>>;\n\n// Helper type to resolve return type, returning 'any' when R is untyped\ntype InferReturnType<R, OPT, K extends keyof OPT> =\n    IsAnyOrAnyIndexed<R> extends true\n        ? any\n        : Awaited<ReturnType<OPT[K] extends Endpoint ? OPT[K] : never>>;\n\nexport class HTTP<R extends Router | Router[\"endpoints\"]> {\n    public authToken: string | undefined;\n    public options: FetchRequestOptions;\n\n    private sdk: ColyseusSDK;\n\n    // alias \"del()\" to \"delete()\"\n    public del = this.delete;\n\n    constructor(sdk: ColyseusSDK, baseOptions: FetchRequestOptions) {\n        this.sdk = sdk;\n        this.options = baseOptions;\n    }\n\n    private async request<\n        M extends HTTPMethod,\n        API extends InferredAPI<R> = InferredAPI<R>,\n        OPT extends Prettify<UnionToIntersection<MethodOptions<API, M>>> = Prettify<UnionToIntersection<MethodOptions<API, M>>>,\n        K extends keyof OPT = keyof OPT,\n        C extends InferContext<OPT[K]> = InferContext<OPT[K]>\n    >(\n        method: M,\n        path: K,\n        options?: FetchRequestOptions<C[\"body\"], C[\"query\"], C[\"params\"]>\n    ): Promise<\n        FetchResponse<Awaited<ReturnType<OPT[K] extends Endpoint ? OPT[K] : never>>>\n    > {\n        return this.executeRequest(method, path, options);\n    }\n\n    // Overload for endpoints WITH required fields (body/query/params)\n    get<\n        API extends InferredAPI<R> = InferredAPI<R>,\n        OPT extends Prettify<UnionToIntersection<MethodOptions<API, \"GET\">>> = Prettify<UnionToIntersection<MethodOptions<API, \"GET\">>>,\n        K extends keyof OPT = keyof OPT,\n        C extends InferContext<OPT[K]> = InferContext<OPT[K]>\n    >(\n        path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends true ? K : never),\n        options: IsAnyOrAnyIndexed<R> extends true\n            ? FetchRequestOptions<any, any, any>\n            : WithRequired<FetchRequestOptions<C[\"body\"], C[\"query\"], C[\"params\"]>, keyof RequiredOptionKeys<C>>\n    ): Promise<\n        FetchResponse<InferReturnType<R, OPT, K>>\n    >;\n\n    // Overload for endpoints WITHOUT required fields (permissive when R is 'any')\n    get<\n        API extends InferredAPI<R> = InferredAPI<R>,\n        OPT extends Prettify<UnionToIntersection<MethodOptions<API, \"GET\">>> = Prettify<UnionToIntersection<MethodOptions<API, \"GET\">>>,\n        K extends keyof OPT = keyof OPT,\n        C extends InferContext<OPT[K]> = InferContext<OPT[K]>\n    >(\n        path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends false ? K : never),\n        options?: IsAnyOrAnyIndexed<R> extends true\n            ? FetchRequestOptions<any, any, any>\n            : FetchRequestOptions<C[\"body\"], C[\"query\"], C[\"params\"]>\n    ): Promise<\n        FetchResponse<InferReturnType<R, OPT, K>>\n    >;\n\n    get(path: any, options?: any): Promise<any> {\n        return this.request(\"GET\", path, options);\n    }\n\n    // Overload for endpoints WITH required fields (body/query/params)\n    post<\n        API extends InferredAPI<R> = InferredAPI<R>,\n        OPT extends Prettify<UnionToIntersection<MethodOptions<API, \"POST\">>> = Prettify<UnionToIntersection<MethodOptions<API, \"POST\">>>,\n        K extends keyof OPT = keyof OPT,\n        C extends InferContext<OPT[K]> = InferContext<OPT[K]>\n    >(\n        path: (IsAnyOrAnyIndexed<R> extends true ? string : never) | (IsAny<API> extends true ? string : never) | (HasRequired<C> extends true ? K : never),\n        options: IsAnyOrAnyIndexed<R> extends true ? FetchRequestOptions<any, any, any> : (IsAny<API> extends true\n            ? FetchRequestOptions<any, any, any>\n            : WithRequired<FetchRequestOptions<C[\"body\"], C[\"query\"], C[\"params\"]>, keyof RequiredOptionKeys<C>>)\n    ): Promise<\n        FetchResponse<InferReturnType<R, OPT, K>>\n    >;\n\n    // Overload for endpoints WITHOUT required fields (permissive when R is 'any')\n    post<\n        API extends InferredAPI<R> = InferredAPI<R>,\n        OPT extends Prettify<UnionToIntersection<MethodOptions<API, \"POST\">>> = Prettify<UnionToIntersection<MethodOptions<API, \"POST\">>>,\n        K extends keyof OPT = keyof OPT,\n        C extends InferContext<OPT[K]> = InferContext<OPT[K]>\n    >(\n        path: (IsAnyOrAnyIndexed<R> extends true ? string : never) | (IsAny<API> extends true ? string : never) | (HasRequired<C> extends false ? K : never),\n        options?: IsAnyOrAnyIndexed<R> extends true ? FetchRequestOptions<any, any, any> : (IsAny<API> extends true\n            ? FetchRequestOptions<any, any, any>\n            : FetchRequestOptions<C[\"body\"], C[\"query\"], C[\"params\"]>)\n    ): Promise<\n        FetchResponse<InferReturnType<R, OPT, K>>\n    >;\n\n    post(path: any, options?: any): Promise<any> {\n        return this.request(\"POST\", path, options);\n    }\n\n    // Overload for endpoints WITH required fields (body/query/params)\n    delete<\n        API extends InferredAPI<R> = InferredAPI<R>,\n        OPT extends Prettify<UnionToIntersection<MethodOptions<API, \"DELETE\">>> = Prettify<UnionToIntersection<MethodOptions<API, \"DELETE\">>>,\n        K extends keyof OPT = keyof OPT,\n        C extends InferContext<OPT[K]> = InferContext<OPT[K]>\n    >(\n        path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends true ? K : never),\n        options: IsAnyOrAnyIndexed<R> extends true\n            ? FetchRequestOptions<any, any, any>\n            : WithRequired<FetchRequestOptions<C[\"body\"], C[\"query\"], C[\"params\"]>, keyof RequiredOptionKeys<C>>\n    ): Promise<\n        FetchResponse<InferReturnType<R, OPT, K>>\n    >;\n\n    // Overload for endpoints WITHOUT required fields (permissive when R is 'any')\n    delete<\n        API extends InferredAPI<R> = InferredAPI<R>,\n        OPT extends Prettify<UnionToIntersection<MethodOptions<API, \"DELETE\">>> = Prettify<UnionToIntersection<MethodOptions<API, \"DELETE\">>>,\n        K extends keyof OPT = keyof OPT,\n        C extends InferContext<OPT[K]> = InferContext<OPT[K]>\n    >(\n        path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends false ? K : never),\n        options?: IsAnyOrAnyIndexed<R> extends true\n            ? FetchRequestOptions<any, any, any>\n            : FetchRequestOptions<C[\"body\"], C[\"query\"], C[\"params\"]>\n    ): Promise<\n        FetchResponse<InferReturnType<R, OPT, K>>\n    >;\n\n    delete(path: any, options?: any): Promise<any> {\n        return this.request(\"DELETE\", path, options);\n    }\n\n    // Overload for endpoints WITH required fields (body/query/params)\n    patch<\n        API extends InferredAPI<R> = InferredAPI<R>,\n        OPT extends Prettify<UnionToIntersection<MethodOptions<API, \"PATCH\">>> = Prettify<UnionToIntersection<MethodOptions<API, \"PATCH\">>>,\n        K extends keyof OPT = keyof OPT,\n        C extends InferContext<OPT[K]> = InferContext<OPT[K]>\n    >(\n        path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends true ? K : never),\n        options: IsAnyOrAnyIndexed<R> extends true\n            ? FetchRequestOptions<any, any, any>\n            : WithRequired<FetchRequestOptions<C[\"body\"], C[\"query\"], C[\"params\"]>, keyof RequiredOptionKeys<C>>\n    ): Promise<\n        FetchResponse<InferReturnType<R, OPT, K>>\n    >;\n\n    // Overload for endpoints WITHOUT required fields (permissive when R is 'any')\n    patch<\n        API extends InferredAPI<R> = InferredAPI<R>,\n        OPT extends Prettify<UnionToIntersection<MethodOptions<API, \"PATCH\">>> = Prettify<UnionToIntersection<MethodOptions<API, \"PATCH\">>>,\n        K extends keyof OPT = keyof OPT,\n        C extends InferContext<OPT[K]> = InferContext<OPT[K]>\n    >(\n        path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends false ? K : never),\n        options?: IsAnyOrAnyIndexed<R> extends true\n            ? FetchRequestOptions<any, any, any>\n            : FetchRequestOptions<C[\"body\"], C[\"query\"], C[\"params\"]>\n    ): Promise<\n        FetchResponse<InferReturnType<R, OPT, K>>\n    >;\n\n    patch(path: any, options?: any): Promise<any> {\n        return this.request(\"PATCH\", path, options);\n    }\n\n    // Overload for endpoints WITH required fields (body/query/params)\n    put<\n        API extends InferredAPI<R> = InferredAPI<R>,\n        OPT extends Prettify<UnionToIntersection<MethodOptions<API, \"PUT\">>> = Prettify<UnionToIntersection<MethodOptions<API, \"PUT\">>>,\n        K extends keyof OPT = keyof OPT,\n        C extends InferContext<OPT[K]> = InferContext<OPT[K]>\n    >(\n        path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends true ? K : never),\n        options: IsAnyOrAnyIndexed<R> extends true\n            ? FetchRequestOptions<any, any, any>\n            : WithRequired<FetchRequestOptions<C[\"body\"], C[\"query\"], C[\"params\"]>, keyof RequiredOptionKeys<C>>\n    ): Promise<\n        FetchResponse<InferReturnType<R, OPT, K>>\n    >;\n\n    // Overload for endpoints WITHOUT required fields (permissive when R is 'any')\n    put<\n        API extends InferredAPI<R> = InferredAPI<R>,\n        OPT extends Prettify<UnionToIntersection<MethodOptions<API, \"PUT\">>> = Prettify<UnionToIntersection<MethodOptions<API, \"PUT\">>>,\n        K extends keyof OPT = keyof OPT,\n        C extends InferContext<OPT[K]> = InferContext<OPT[K]>\n    >(\n        path: IsAnyOrAnyIndexed<R> extends true ? string : (HasRequired<C> extends false ? K : never),\n        options?: IsAnyOrAnyIndexed<R> extends true\n            ? FetchRequestOptions<any, any, any>\n            : FetchRequestOptions<C[\"body\"], C[\"query\"], C[\"params\"]>\n    ): Promise<\n        FetchResponse<InferReturnType<R, OPT, K>>\n    >;\n\n    put(path: any, options?: any): Promise<any> {\n        return this.request(\"PUT\", path, options);\n    }\n\n    protected async executeRequest<M extends HTTPMethod>(\n        method: M,\n        path: any,\n        requestOptions?: any\n    ): Promise<any> {\n        //\n        // FIXME: if FormData is provided, merging \"baseOptions.body\" with\n        // \"options.body\" will not work as intended\n        //\n        let body = (this.options.body)\n            ? { ...this.options.body, ...(requestOptions?.body as object || {}) }\n            : requestOptions?.body;\n\n        const query = (this.options.query)\n            ? { ...this.options.query, ...(requestOptions?.query as object || {}) }\n            : requestOptions?.query;\n\n        const params = (this.options.params)\n            ? { ...this.options.params, ...(requestOptions?.params as object || {}) }\n            : requestOptions?.params;\n\n        const headers = new Headers(\n            (this.options.headers)\n                ? { ...this.options.headers, ...(requestOptions?.headers || {}) }\n                : requestOptions?.headers\n        );\n\n        // Add Authorization header if authToken is set\n        if (this.authToken && !headers.has(\"authorization\")) {\n            headers.set(\"authorization\", `Bearer ${this.authToken}`);\n        }\n\n        // Stringify JSON-serializable objects for fetch() body\n        if (isJSONSerializable(body) && typeof body === 'object' && body !== null) {\n            if (!headers.has(\"content-type\")) {\n                headers.set(\"content-type\", \"application/json\");\n            }\n            for (const [key, value] of Object.entries(body)) {\n                if (value instanceof Date) {\n                    body[key] = value.toISOString();\n                }\n            }\n            body = JSON.stringify(body);\n        }\n\n        const mergedOptions = {\n            credentials: requestOptions?.credentials || \"include\",\n            ...this.options,\n            ...requestOptions,\n            query,\n            params,\n            headers,\n            body,\n            method,\n        };\n\n        const url = getURLWithQueryParams(this.sdk['getHttpEndpoint'](path.toString()), mergedOptions);\n\n        let raw: Response;\n        try {\n            raw = await fetch(url, mergedOptions);\n        } catch (err: any) {\n            // If it's an AbortError, re-throw as-is\n            if (err.name === 'AbortError') {\n                throw err;\n            }\n            // Re-throw with network error code at top level (e.g. ECONNREFUSED)\n            const networkError: ServerError = new ServerError(err.cause?.code || err.code, err.message);\n            networkError.response = raw;\n            networkError.cause = err.cause;\n            throw networkError;\n        }\n        const contentType = raw.headers.get(\"content-type\");\n\n        let data: any;\n\n        // TODO: improve content-type detection here!\n        if (contentType?.indexOf(\"json\")) {\n            data = await raw.json();\n\n        } else if (contentType?.indexOf(\"text\")) {\n            data = await raw.text();\n\n        } else {\n            data = await raw.blob();\n        }\n\n        if (!raw.ok) {\n            throw new ServerError(data.code ?? raw.status, data.error ?? data.message ?? raw.statusText, {\n                headers: raw.headers,\n                status: raw.status,\n                response: raw,\n                data\n            });\n        }\n\n        return {\n            raw,\n            data,\n            headers: raw.headers,\n            status: raw.status,\n            statusText: raw.statusText,\n        };\n    }\n}\n"],"names":[],"mappings":"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"}