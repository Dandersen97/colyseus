// Copyright (c) 2026 Endel Dreyer.
//
// This software is released under the MIT License.
// https://opensource.org/license/MIT
//
// colyseus.js@0.17.29
import { ServerError } from './errors/Errors.mjs';

function isJSONSerializable(value) {
    if (value === undefined) {
        return false;
    }
    const t = typeof value;
    if (t === "string" || t === "number" || t === "boolean" || t === null) {
        return true;
    }
    if (t !== "object") {
        return false;
    }
    if (Array.isArray(value)) {
        return true;
    }
    if (value.buffer) {
        return false;
    }
    return ((value.constructor && value.constructor.name === "Object") ||
        typeof value.toJSON === "function");
}
const JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(request) {
    const _contentType = request.headers.get("content-type");
    const textTypes = new Set([
        "image/svg",
        "application/xml",
        "application/xhtml",
        "application/html",
    ]);
    if (!_contentType) {
        return "json";
    }
    const contentType = _contentType.split(";").shift() || "";
    if (JSON_RE.test(contentType)) {
        return "json";
    }
    if (textTypes.has(contentType) || contentType.startsWith("text/")) {
        return "text";
    }
    return "blob";
}
function getURLWithQueryParams(url, option) {
    const { params, query } = option || {};
    // Parse the URL and extract existing query parameters
    const [urlPath, urlQuery] = url.split("?");
    let path = urlPath;
    // Handle params substitution
    if (params) {
        if (Array.isArray(params)) {
            const paramPaths = path.split("/").filter((p) => p.startsWith(":"));
            for (const [index, key] of paramPaths.entries()) {
                const value = params[index];
                path = path.replace(key, value);
            }
        }
        else {
            for (const [key, value] of Object.entries(params)) {
                path = path.replace(`:${key}`, String(value));
            }
        }
    }
    // Merge query parameters from URL and options
    const queryParams = new URLSearchParams(urlQuery);
    if (query) {
        for (const [key, value] of Object.entries(query)) {
            if (value == null)
                continue;
            queryParams.set(key, String(value));
        }
    }
    // Build final URL
    let queryParamString = queryParams.toString();
    queryParamString = queryParamString.length > 0 ? `?${queryParamString}`.replace(/\+/g, "%20") : "";
    return `${path}${queryParamString}`;
}
class HTTP {
    authToken;
    options;
    sdk;
    // alias "del()" to "delete()"
    del = this.delete;
    constructor(sdk, baseOptions) {
        this.sdk = sdk;
        this.options = baseOptions;
    }
    async request(method, path, options) {
        return this.executeRequest(method, path, options);
    }
    get(path, options) {
        return this.request("GET", path, options);
    }
    post(path, options) {
        return this.request("POST", path, options);
    }
    delete(path, options) {
        return this.request("DELETE", path, options);
    }
    patch(path, options) {
        return this.request("PATCH", path, options);
    }
    put(path, options) {
        return this.request("PUT", path, options);
    }
    async executeRequest(method, path, requestOptions) {
        //
        // FIXME: if FormData is provided, merging "baseOptions.body" with
        // "options.body" will not work as intended
        //
        let body = (this.options.body)
            ? { ...this.options.body, ...(requestOptions?.body || {}) }
            : requestOptions?.body;
        const query = (this.options.query)
            ? { ...this.options.query, ...(requestOptions?.query || {}) }
            : requestOptions?.query;
        const params = (this.options.params)
            ? { ...this.options.params, ...(requestOptions?.params || {}) }
            : requestOptions?.params;
        const headers = new Headers((this.options.headers)
            ? { ...this.options.headers, ...(requestOptions?.headers || {}) }
            : requestOptions?.headers);
        // Add Authorization header if authToken is set
        if (this.authToken && !headers.has("authorization")) {
            headers.set("authorization", `Bearer ${this.authToken}`);
        }
        // Stringify JSON-serializable objects for fetch() body
        if (isJSONSerializable(body) && typeof body === 'object' && body !== null) {
            if (!headers.has("content-type")) {
                headers.set("content-type", "application/json");
            }
            for (const [key, value] of Object.entries(body)) {
                if (value instanceof Date) {
                    body[key] = value.toISOString();
                }
            }
            body = JSON.stringify(body);
        }
        const mergedOptions = {
            credentials: requestOptions?.credentials || "include",
            ...this.options,
            ...requestOptions,
            query,
            params,
            headers,
            body,
            method,
        };
        const url = getURLWithQueryParams(this.sdk['getHttpEndpoint'](path.toString()), mergedOptions);
        let raw;
        try {
            raw = await fetch(url, mergedOptions);
        }
        catch (err) {
            // If it's an AbortError, re-throw as-is
            if (err.name === 'AbortError') {
                throw err;
            }
            // Re-throw with network error code at top level (e.g. ECONNREFUSED)
            const networkError = new ServerError(err.cause?.code || err.code, err.message);
            networkError.response = raw;
            networkError.cause = err.cause;
            throw networkError;
        }
        const contentType = raw.headers.get("content-type");
        let data;
        // TODO: improve content-type detection here!
        if (contentType?.indexOf("json")) {
            data = await raw.json();
        }
        else if (contentType?.indexOf("text")) {
            data = await raw.text();
        }
        else {
            data = await raw.blob();
        }
        if (!raw.ok) {
            throw new ServerError(data.code ?? raw.status, data.error ?? data.message ?? raw.statusText, {
                headers: raw.headers,
                status: raw.status,
                response: raw,
                data
            });
        }
        return {
            raw,
            data,
            headers: raw.headers,
            status: raw.status,
            statusText: raw.statusText,
        };
    }
}

export { HTTP, detectResponseType, isJSONSerializable };
//# sourceMappingURL=HTTP.mjs.map
