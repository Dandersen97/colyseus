// Copyright (c) 2026 Endel Dreyer.
//
// This software is released under the MIT License.
// https://opensource.org/license/MIT
//
// colyseus.js@0.17.29
'use strict';

var tslib = require('tslib');
var H3Transport = require('./transport/H3Transport.cjs');
var WebSocketTransport = require('./transport/WebSocketTransport.cjs');
var sharedTypes = require('@colyseus/shared-types');

var _Connection__offlineListener;
const onOfflineListeners = [];
const hasGlobalEventListeners = typeof (addEventListener) === "function" && typeof (removeEventListener) === "function";
if (hasGlobalEventListeners) {
    /**
     * Detects when the network is offline and closes all connections.
     * (When switching wifi networks, etc.)
     */
    addEventListener("offline", () => {
        console.warn(`@colyseus/sdk: ðŸ›‘ Network offline. Closing ${onOfflineListeners.length} connection(s)`);
        onOfflineListeners.forEach((listener) => listener());
    }, false);
}
class Connection {
    constructor(protocol) {
        this.events = {};
        _Connection__offlineListener.set(this, (hasGlobalEventListeners) ? () => this.close(sharedTypes.CloseCode.MAY_TRY_RECONNECT) : null);
        switch (protocol) {
            case "h3":
                this.transport = new H3Transport.H3TransportTransport(this.events);
                break;
            default:
                this.transport = new WebSocketTransport.WebSocketTransport(this.events);
                break;
        }
    }
    connect(url, options) {
        if (hasGlobalEventListeners) {
            const onOpen = this.events.onopen;
            this.events.onopen = (ev) => {
                onOfflineListeners.push(tslib.__classPrivateFieldGet(this, _Connection__offlineListener, "f"));
                onOpen === null || onOpen === void 0 ? void 0 : onOpen(ev);
            };
            const onClose = this.events.onclose;
            this.events.onclose = (ev) => {
                onOfflineListeners.splice(onOfflineListeners.indexOf(tslib.__classPrivateFieldGet(this, _Connection__offlineListener, "f")), 1);
                onClose === null || onClose === void 0 ? void 0 : onClose(ev);
            };
        }
        this.url = url;
        this.options = options;
        this.transport.connect(url, options);
    }
    send(data) {
        this.transport.send(data);
    }
    sendUnreliable(data) {
        this.transport.sendUnreliable(data);
    }
    reconnect(queryParams) {
        const url = new URL(this.url);
        // override query params
        for (const key in queryParams) {
            url.searchParams.set(key, queryParams[key]);
        }
        this.transport.connect(url.toString(), this.options);
    }
    close(code, reason) {
        this.transport.close(code, reason);
    }
    get isOpen() {
        return this.transport.isOpen;
    }
}
_Connection__offlineListener = new WeakMap();

exports.Connection = Connection;
//# sourceMappingURL=Connection.cjs.map
