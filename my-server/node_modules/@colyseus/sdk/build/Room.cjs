// Copyright (c) 2026 Endel Dreyer.
//
// This software is released under the MIT License.
// https://opensource.org/license/MIT
//
// colyseus.js@0.17.29
'use strict';

var tslib = require('tslib');
var sharedTypes = require('@colyseus/shared-types');
var schema = require('@colyseus/schema');
var msgpackr = require('@colyseus/msgpackr');
var Connection = require('./Connection.cjs');
var Serializer = require('./serializer/Serializer.cjs');
var nanoevents = require('./core/nanoevents.cjs');
var signal = require('./core/signal.cjs');
var SchemaSerializer = require('./serializer/SchemaSerializer.cjs');
var utils = require('./core/utils.cjs');

var _Room_lastPingTime, _Room_pingCallback;
class Room {
    constructor(name, rootSchema) {
        // Public signals
        this.onStateChange = signal.createSignal();
        this.onError = signal.createSignal();
        this.onLeave = signal.createSignal();
        this.onReconnect = signal.createSignal();
        this.onDrop = signal.createSignal();
        this.onJoin = signal.createSignal();
        // reconnection logic
        this.reconnection = {
            retryCount: 0,
            maxRetries: 15,
            delay: 100,
            minDelay: 100,
            maxDelay: 5000,
            minUptime: 5000,
            backoff: exponentialBackoff,
            maxEnqueuedMessages: 10,
            enqueuedMessages: [],
            isReconnecting: false,
        };
        this.joinedAtTime = 0;
        this.onMessageHandlers = nanoevents.createNanoEvents();
        _Room_lastPingTime.set(this, 0);
        _Room_pingCallback.set(this, undefined);
        this.name = name;
        this.packr = new msgpackr.Packr();
        // msgpackr workaround: force buffer to be created.
        this.packr.encode(undefined);
        if (rootSchema) {
            const serializer = new (Serializer.getSerializer("schema"));
            this.serializer = serializer;
            const state = new rootSchema();
            serializer.state = state;
            serializer.decoder = new schema.Decoder(state);
        }
        this.onLeave(() => {
            this.removeAllListeners();
            this.destroy();
        });
    }
    connect(endpoint, options, headers) {
        var _a;
        this.connection = new Connection.Connection(options.protocol);
        this.connection.events.onmessage = this.onMessageCallback.bind(this);
        this.connection.events.onclose = (e) => {
            var _a;
            if (this.joinedAtTime === 0) {
                (_a = console.warn) === null || _a === void 0 ? void 0 : _a.call(console, `Room connection was closed unexpectedly (${e.code}): ${e.reason}`);
                this.onError.invoke(e.code, e.reason);
                return;
            }
            if (e.code === sharedTypes.CloseCode.NO_STATUS_RECEIVED ||
                e.code === sharedTypes.CloseCode.ABNORMAL_CLOSURE ||
                e.code === sharedTypes.CloseCode.GOING_AWAY ||
                e.code === sharedTypes.CloseCode.MAY_TRY_RECONNECT) {
                this.onDrop.invoke(e.code, e.reason);
                this.handleReconnection();
            }
            else {
                this.onLeave.invoke(e.code, e.reason);
            }
        };
        this.connection.events.onerror = (e) => {
            this.onError.invoke(e.code, e.reason);
        };
        /**
         * if local serializer has state, it means we don't need to receive the
         * handshake from the server
         */
        const skipHandshake = (((_a = this.serializer) === null || _a === void 0 ? void 0 : _a.getState()) !== undefined);
        if (options.protocol === "h3") {
            // FIXME: refactor this.
            const url = new URL(endpoint);
            this.connection.connect(url.origin, Object.assign(Object.assign({}, options), { skipHandshake }));
        }
        else {
            this.connection.connect(`${endpoint}${skipHandshake ? "&skipHandshake=1" : ""}`, headers);
        }
    }
    leave(consented = true) {
        return new Promise((resolve) => {
            this.onLeave((code) => resolve(code));
            if (this.connection) {
                if (consented) {
                    this.packr.buffer[0] = sharedTypes.Protocol.LEAVE_ROOM;
                    this.connection.send(this.packr.buffer.subarray(0, 1));
                }
                else {
                    this.connection.close();
                }
            }
            else {
                this.onLeave.invoke(sharedTypes.CloseCode.CONSENTED);
            }
        });
    }
    onMessage(type, callback) {
        return this.onMessageHandlers.on(this.getMessageHandlerKey(type), callback);
    }
    ping(callback) {
        var _a;
        // skip if connection is not open
        if (!((_a = this.connection) === null || _a === void 0 ? void 0 : _a.isOpen)) {
            return;
        }
        tslib.__classPrivateFieldSet(this, _Room_lastPingTime, utils.now(), "f");
        tslib.__classPrivateFieldSet(this, _Room_pingCallback, callback, "f");
        this.packr.buffer[0] = sharedTypes.Protocol.PING;
        this.connection.send(this.packr.buffer.subarray(0, 1));
    }
    send(messageType, payload) {
        const it = { offset: 1 };
        this.packr.buffer[0] = sharedTypes.Protocol.ROOM_DATA;
        if (typeof (messageType) === "string") {
            schema.encode.string(this.packr.buffer, messageType, it);
        }
        else {
            schema.encode.number(this.packr.buffer, messageType, it);
        }
        // force packr to use beginning of the buffer
        this.packr.position = 0;
        const data = (payload !== undefined)
            ? this.packr.pack(payload, 2048 + it.offset) // 2048 = RESERVE_START_SPACE
            : this.packr.buffer.subarray(0, it.offset);
        // If connection is not open, buffer the message
        if (!this.connection.isOpen) {
            enqueueMessage(this, new Uint8Array(data));
        }
        else {
            this.connection.send(data);
        }
    }
    sendUnreliable(type, message) {
        // If connection is not open, skip
        if (!this.connection.isOpen) {
            return;
        }
        const it = { offset: 1 };
        this.packr.buffer[0] = sharedTypes.Protocol.ROOM_DATA;
        if (typeof (type) === "string") {
            schema.encode.string(this.packr.buffer, type, it);
        }
        else {
            schema.encode.number(this.packr.buffer, type, it);
        }
        // force packr to use beginning of the buffer
        this.packr.position = 0;
        const data = (message !== undefined)
            ? this.packr.pack(message, 2048 + it.offset) // 2048 = RESERVE_START_SPACE
            : this.packr.buffer.subarray(0, it.offset);
        this.connection.sendUnreliable(data);
    }
    sendBytes(type, bytes) {
        const it = { offset: 1 };
        this.packr.buffer[0] = sharedTypes.Protocol.ROOM_DATA_BYTES;
        if (typeof (type) === "string") {
            schema.encode.string(this.packr.buffer, type, it);
        }
        else {
            schema.encode.number(this.packr.buffer, type, it);
        }
        // check if buffer needs to be resized
        // TODO: can we avoid this?
        if (bytes.byteLength + it.offset > this.packr.buffer.byteLength) {
            const newBuffer = new Uint8Array(it.offset + bytes.byteLength);
            newBuffer.set(this.packr.buffer);
            this.packr.useBuffer(newBuffer);
        }
        this.packr.buffer.set(bytes, it.offset);
        // If connection is not open, buffer the message
        if (!this.connection.isOpen) {
            enqueueMessage(this, this.packr.buffer.subarray(0, it.offset + bytes.byteLength));
        }
        else {
            this.connection.send(this.packr.buffer.subarray(0, it.offset + bytes.byteLength));
        }
    }
    get state() {
        return this.serializer.getState();
    }
    removeAllListeners() {
        this.onJoin.clear();
        this.onStateChange.clear();
        this.onError.clear();
        this.onLeave.clear();
        this.onReconnect.clear();
        this.onDrop.clear();
        this.onMessageHandlers.events = {};
        if (this.serializer instanceof SchemaSerializer.SchemaSerializer) {
            // Remove callback references
            this.serializer.decoder.root.callbacks = {};
        }
    }
    onMessageCallback(event) {
        var _a;
        const buffer = new Uint8Array(event.data);
        const it = { offset: 1 };
        const code = buffer[0];
        if (code === sharedTypes.Protocol.JOIN_ROOM) {
            const reconnectionToken = schema.decode.utf8Read(buffer, it, buffer[it.offset++]);
            this.serializerId = schema.decode.utf8Read(buffer, it, buffer[it.offset++]);
            // Instantiate serializer if not locally available.
            if (!this.serializer) {
                const serializer = Serializer.getSerializer(this.serializerId);
                this.serializer = new serializer();
            }
            // apply handshake on first join (no need to do this on reconnect)
            if (buffer.byteLength > it.offset && this.serializer.handshake) {
                this.serializer.handshake(buffer, it);
            }
            if (this.joinedAtTime === 0) {
                this.joinedAtTime = Date.now();
                this.onJoin.invoke();
            }
            else {
                console.info(`[Colyseus reconnection]: ${String.fromCodePoint(0x2705)} reconnection successful!`); // âœ…
                this.reconnection.isReconnecting = false;
                this.onReconnect.invoke();
            }
            this.reconnectionToken = `${this.roomId}:${reconnectionToken}`;
            // acknowledge successfull JOIN_ROOM
            this.packr.buffer[0] = sharedTypes.Protocol.JOIN_ROOM;
            this.connection.send(this.packr.buffer.subarray(0, 1));
            // Send any enqueued messages that were buffered while disconnected
            if (this.reconnection.enqueuedMessages.length > 0) {
                for (const message of this.reconnection.enqueuedMessages) {
                    this.connection.send(message.data);
                }
                // Clear the buffer after sending
                this.reconnection.enqueuedMessages = [];
            }
        }
        else if (code === sharedTypes.Protocol.ERROR) {
            const code = schema.decode.number(buffer, it);
            const message = schema.decode.string(buffer, it);
            this.onError.invoke(code, message);
        }
        else if (code === sharedTypes.Protocol.LEAVE_ROOM) {
            this.leave();
        }
        else if (code === sharedTypes.Protocol.ROOM_STATE) {
            this.serializer.setState(buffer, it);
            this.onStateChange.invoke(this.serializer.getState());
        }
        else if (code === sharedTypes.Protocol.ROOM_STATE_PATCH) {
            this.serializer.patch(buffer, it);
            this.onStateChange.invoke(this.serializer.getState());
        }
        else if (code === sharedTypes.Protocol.ROOM_DATA) {
            const type = (schema.decode.stringCheck(buffer, it))
                ? schema.decode.string(buffer, it)
                : schema.decode.number(buffer, it);
            const message = (buffer.byteLength > it.offset)
                ? msgpackr.unpack(buffer, { start: it.offset })
                : undefined;
            this.dispatchMessage(type, message);
        }
        else if (code === sharedTypes.Protocol.ROOM_DATA_BYTES) {
            const type = (schema.decode.stringCheck(buffer, it))
                ? schema.decode.string(buffer, it)
                : schema.decode.number(buffer, it);
            this.dispatchMessage(type, buffer.subarray(it.offset));
        }
        else if (code === sharedTypes.Protocol.PING) {
            (_a = tslib.__classPrivateFieldGet(this, _Room_pingCallback, "f")) === null || _a === void 0 ? void 0 : _a.call(this, Math.round(utils.now() - tslib.__classPrivateFieldGet(this, _Room_lastPingTime, "f")));
            tslib.__classPrivateFieldSet(this, _Room_pingCallback, undefined, "f");
        }
    }
    dispatchMessage(type, message) {
        var _a;
        const messageType = this.getMessageHandlerKey(type);
        if (this.onMessageHandlers.events[messageType]) {
            this.onMessageHandlers.emit(messageType, message);
        }
        else if (this.onMessageHandlers.events['*']) {
            this.onMessageHandlers.emit('*', type, message);
        }
        else if (!messageType.startsWith("__")) { // ignore internal messages
            (_a = console.warn) === null || _a === void 0 ? void 0 : _a.call(console, `@colyseus/sdk: onMessage() not registered for type '${type}'.`);
        }
    }
    destroy() {
        if (this.serializer) {
            this.serializer.teardown();
        }
    }
    getMessageHandlerKey(type) {
        switch (typeof (type)) {
            // string
            case "string": return type;
            // number
            case "number": return `i${type}`;
            default: throw new Error("invalid message type.");
        }
    }
    handleReconnection() {
        if (Date.now() - this.joinedAtTime < this.reconnection.minUptime) {
            console.info(`[Colyseus reconnection]: ${String.fromCodePoint(0x274C)} Room has not been up for long enough for automatic reconnection. (min uptime: ${this.reconnection.minUptime}ms)`); // âŒ
            this.onLeave.invoke(sharedTypes.CloseCode.ABNORMAL_CLOSURE, "Room uptime too short for reconnection.");
            return;
        }
        if (!this.reconnection.isReconnecting) {
            this.reconnection.retryCount = 0;
            this.reconnection.isReconnecting = true;
        }
        this.retryReconnection();
    }
    retryReconnection() {
        if (this.reconnection.retryCount >= this.reconnection.maxRetries) {
            // No more retries
            console.info(`[Colyseus reconnection]: ${String.fromCodePoint(0x274C)} âŒ Reconnection failed after ${this.reconnection.maxRetries} attempts.`); // âŒ
            this.reconnection.isReconnecting = false;
            this.onLeave.invoke(sharedTypes.CloseCode.FAILED_TO_RECONNECT, "No more retries. Reconnection failed.");
            return;
        }
        this.reconnection.retryCount++;
        const delay = Math.min(this.reconnection.maxDelay, Math.max(this.reconnection.minDelay, this.reconnection.backoff(this.reconnection.retryCount, this.reconnection.delay)));
        console.info(`[Colyseus reconnection]: ${String.fromCodePoint(0x023F3)} will retry in ${(delay / 1000).toFixed(1)} seconds...`); // ðŸ”„
        // Wait before attempting reconnection
        setTimeout(() => {
            try {
                console.info(`[Colyseus reconnection]: ${String.fromCodePoint(0x1F504)} Re-establishing sessionId '${this.sessionId}' with roomId '${this.roomId}'... (attempt ${this.reconnection.retryCount} of ${this.reconnection.maxRetries})`); // ðŸ”„
                this.connection.reconnect({
                    reconnectionToken: this.reconnectionToken.split(":")[1],
                    skipHandshake: true, // we already applied the handshake on first join
                });
            }
            catch (e) {
                this.retryReconnection();
            }
        }, delay);
    }
}
_Room_lastPingTime = new WeakMap(), _Room_pingCallback = new WeakMap();
const exponentialBackoff = (attempt, delay) => {
    return Math.floor(Math.pow(2, attempt) * delay);
};
function enqueueMessage(room, message) {
    room.reconnection.enqueuedMessages.push({ data: message });
    if (room.reconnection.enqueuedMessages.length > room.reconnection.maxEnqueuedMessages) {
        room.reconnection.enqueuedMessages.shift();
    }
}

exports.Room = Room;
//# sourceMappingURL=Room.cjs.map
