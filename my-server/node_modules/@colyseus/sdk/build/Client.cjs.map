{"version":3,"file":"Client.cjs","sources":["../src/Client.ts"],"sourcesContent":["import { CloseCode, Protocol, type InferState, type SDKTypes, type ServerRoomLike, type ISeatReservation } from '@colyseus/shared-types';\n\nimport { MatchMakeError, ServerError } from './errors/Errors.ts';\nimport { Room } from './Room.ts';\nimport { SchemaConstructor } from './serializer/SchemaSerializer.ts';\nimport { HTTP } from './HTTP.ts';\nimport { Auth } from './Auth.ts';\nimport { Connection } from './Connection.ts';\nimport { discordURLBuilder } from './3rd_party/discord.ts';\n\nexport type JoinOptions = any;\nexport type { ISeatReservation };\n\n// - React Native does not provide `window.location`\n// - Cocos Creator (Native) does not provide `window.location.hostname`\nconst DEFAULT_ENDPOINT = (typeof (window) !== \"undefined\" &&  typeof (window?.location?.hostname) !== \"undefined\")\n    ? `${window.location.protocol.replace(\"http\", \"ws\")}//${window.location.hostname}${(window.location.port && `:${window.location.port}`)}`\n    : \"ws://127.0.0.1:2567\";\n\nexport interface EndpointSettings {\n    hostname: string,\n    secure: boolean,\n    port?: number,\n    pathname?: string,\n    searchParams?: string,\n    protocol?: \"ws\" | \"h3\";\n}\n\nexport interface ClientOptions {\n    headers?: { [id: string]: string };\n    urlBuilder?: (url: URL) => string;\n    protocol?: \"ws\" | \"h3\";\n}\n\nexport interface LatencyOptions {\n    /** \"ws\" for WebSocket, \"h3\" for WebTransport (default: \"ws\") */\n    protocol?: \"ws\" | \"h3\";\n    /** Number of pings to send (default: 1). Returns the average latency when > 1. */\n    pingCount?: number;\n}\n\nexport class ColyseusSDK<ServerType extends SDKTypes = any, UserData = any> {\n    static VERSION = \"0.17\";\n\n    /**\n     * The HTTP client to make requests to the server.\n     */\n    public http: HTTP<ServerType['~routes']>;\n\n    /**\n     * The authentication module to authenticate into requests and rooms.\n     */\n    public auth: Auth<UserData>;\n\n    /**\n     * The settings used to connect to the server.\n     */\n    public settings: EndpointSettings;\n\n    protected urlBuilder: (url: URL) => string;\n\n    constructor(\n        settings: string | EndpointSettings = DEFAULT_ENDPOINT,\n        options?: ClientOptions,\n    ) {\n        if (typeof (settings) === \"string\") {\n\n            //\n            // endpoint by url\n            //\n            const url = (settings.startsWith(\"/\"))\n                ? new URL(settings, DEFAULT_ENDPOINT)\n                : new URL(settings);\n\n            const secure = (url.protocol === \"https:\" || url.protocol === \"wss:\");\n            const port = Number(url.port || (secure ? 443 : 80));\n\n            this.settings = {\n                hostname: url.hostname,\n                pathname: url.pathname,\n                port,\n                secure,\n                searchParams: url.searchParams.toString() || undefined,\n            };\n\n        } else {\n            //\n            // endpoint by settings\n            //\n            if (settings.port === undefined) {\n                settings.port = (settings.secure) ? 443 : 80;\n            }\n            if (settings.pathname === undefined) {\n                settings.pathname = \"\";\n            }\n            this.settings = settings;\n        }\n\n        // make sure pathname does not end with \"/\"\n        if (this.settings.pathname.endsWith(\"/\")) {\n            this.settings.pathname = this.settings.pathname.slice(0, -1);\n        }\n\n        // specify room connection protocol if provided\n        if (options?.protocol) {\n            this.settings.protocol = options.protocol;\n        }\n\n        this.http = new HTTP(this, {\n            headers: options?.headers || {},\n        });\n        this.auth = new Auth(this.http);\n\n        this.urlBuilder = options?.urlBuilder;\n\n        //\n        // Discord Embedded SDK requires a custom URL builder\n        //\n        if (\n            !this.urlBuilder &&\n            typeof (window) !== \"undefined\" &&\n            window?.location?.hostname?.includes(\"discordsays.com\")\n        ) {\n            this.urlBuilder = discordURLBuilder;\n            console.log(\"Colyseus SDK: Discord Embedded SDK detected. Using custom URL builder.\");\n        }\n    }\n\n    /**\n     * Select the endpoint with the lowest latency.\n     * @param endpoints Array of endpoints to select from.\n     * @param options Client options.\n     * @param latencyOptions Latency measurement options (protocol, pingCount).\n     * @returns The client with the lowest latency.\n     */\n    static async selectByLatency<ServerType extends SDKTypes = any, UserData = any>(\n        endpoints: Array<string | EndpointSettings>,\n        options?: ClientOptions,\n        latencyOptions: LatencyOptions = {}\n    ) {\n        const clients = endpoints.map(endpoint => new ColyseusSDK<ServerType, UserData>(endpoint, options));\n\n        const latencies = (await Promise.allSettled(clients.map((client, index) => client.getLatency(latencyOptions).then(latency => {\n            const settings = clients[index].settings;\n            console.log(`ðŸ›œ Endpoint Latency: ${latency}ms - ${settings.hostname}:${settings.port}${settings.pathname}`);\n            return [index, latency]\n        }))))\n            .filter((result) => result.status === 'fulfilled')\n            .map(result => result.value);\n\n        if (latencies.length === 0) {\n            throw new Error('All endpoints failed to respond');\n        }\n\n        return clients[latencies.sort((a, b) => a[1] - b[1])[0][0]];\n    }\n\n    // Overload: Use room name from ServerType to infer room type\n    public async joinOrCreate<R extends keyof ServerType['~rooms'], State = InferState<ServerType['~rooms'][R]['~room'], never>>(\n        roomName: R,\n        options?: Parameters<ServerType['~rooms'][R]['~room']['onJoin']>[1],\n        rootSchema?: SchemaConstructor<State>\n    ): Promise<Room<ServerType['~rooms'][R]['~room'], State>>\n    // Overload: Pass RoomType directly to extract state\n    public async joinOrCreate<RoomType extends ServerRoomLike>(\n        roomName: string,\n        options?: Parameters<NonNullable<RoomType['onJoin']>>[1],\n        rootSchema?: SchemaConstructor<RoomType['state']>\n    ): Promise<Room<RoomType, RoomType['state']>>\n    // Overload: Pass State type directly\n    public async joinOrCreate<State = any>(\n        roomName: string,\n        options?: JoinOptions,\n        rootSchema?: SchemaConstructor<State>\n    ): Promise<Room<any, State>>\n    // Implementation\n    public async joinOrCreate<T = any>(roomName: string, options: JoinOptions = {}, rootSchema?: SchemaConstructor<T>) {\n        return await this.createMatchMakeRequest<T>('joinOrCreate', roomName, options, rootSchema);\n    }\n\n    // Overload: Use room name from ServerType to infer room type\n    public async create<R extends keyof ServerType['~rooms'], State = InferState<ServerType['~rooms'][R]['~room'], never>>(\n        roomName: R,\n        options?: Parameters<ServerType['~rooms'][R]['~room']['onJoin']>[1],\n        rootSchema?: SchemaConstructor<State>\n    ): Promise<Room<ServerType['~rooms'][R]['~room'], State>>\n    // Overload: Pass RoomType directly to extract state\n    public async create<RoomType extends ServerRoomLike>(\n        roomName: string,\n        options?: Parameters<NonNullable<RoomType['onJoin']>>[1],\n        rootSchema?: SchemaConstructor<RoomType['state']>\n    ): Promise<Room<RoomType, RoomType['state']>>\n    // Overload: Pass State type directly\n    public async create<State = any>(\n        roomName: string,\n        options?: JoinOptions,\n        rootSchema?: SchemaConstructor<State>\n    ): Promise<Room<any, State>>\n    // Implementation\n    public async create<T = any>(roomName: string, options: JoinOptions = {}, rootSchema?: SchemaConstructor<T>) {\n        return await this.createMatchMakeRequest<T>('create', roomName, options, rootSchema);\n    }\n\n    // Overload: Use room name from ServerType to infer room type\n    public async join<R extends keyof ServerType['~rooms'], State = InferState<ServerType['~rooms'][R]['~room'], never>>(\n        roomName: R,\n        options?: Parameters<ServerType['~rooms'][R]['~room']['onJoin']>[1],\n        rootSchema?: SchemaConstructor<State>\n    ): Promise<Room<ServerType['~rooms'][R]['~room'], State>>\n    // Overload: Pass RoomType directly to extract state\n    public async join<RoomType extends ServerRoomLike>(\n        roomName: string,\n        options?: Parameters<NonNullable<RoomType['onJoin']>>[1],\n        rootSchema?: SchemaConstructor<RoomType['state']>\n    ): Promise<Room<RoomType, RoomType['state']>>\n    // Overload: Pass State type directly\n    public async join<State = any>(\n        roomName: string,\n        options?: JoinOptions,\n        rootSchema?: SchemaConstructor<State>\n    ): Promise<Room<any, State>>\n    // Implementation\n    public async join<T = any>(roomName: string, options: JoinOptions = {}, rootSchema?: SchemaConstructor<T>) {\n        return await this.createMatchMakeRequest<T>('join', roomName, options, rootSchema);\n    }\n\n    // Overload: Use room name from ServerType to infer room type\n    public async joinById<R extends keyof ServerType['~rooms'], State = InferState<ServerType['~rooms'][R]['~room'], never>>(\n        roomName: R,\n        options?: Parameters<ServerType['~rooms'][R]['~room']['onJoin']>[1],\n        rootSchema?: SchemaConstructor<State>\n    ): Promise<Room<ServerType['~rooms'][R]['~room'], State>>\n    // Overload: Pass RoomType directly to extract state\n    public async joinById<RoomType extends ServerRoomLike>(\n        roomId: string,\n        options?: Parameters<NonNullable<RoomType['onJoin']>>[1],\n        rootSchema?: SchemaConstructor<RoomType['state']>\n    ): Promise<Room<RoomType, RoomType['state']>>\n    // Overload: Pass State type directly\n    public async joinById<State = any>(\n        roomId: string,\n        options?: JoinOptions,\n        rootSchema?: SchemaConstructor<State>\n    ): Promise<Room<any, State>>\n    // Implementation\n    public async joinById<T = any>(roomId: string, options: JoinOptions = {}, rootSchema?: SchemaConstructor<T>) {\n        return await this.createMatchMakeRequest<T>('joinById', roomId, options, rootSchema);\n    }\n\n    /**\n     * Re-establish connection with a room this client was previously connected to.\n     *\n     * @param reconnectionToken The `room.reconnectionToken` from previously connected room.\n     * @param rootSchema (optional) Concrete root schema definition\n     * @returns Promise<Room>\n     */\n    // Overload: Use room name from ServerType to infer room type\n    public async reconnect<R extends keyof ServerType['~rooms']>(reconnectionToken: string, roomName?: R): Promise<Room<ServerType['~rooms'][R]['~room']>>\n    // Overload: Pass RoomType directly to extract state\n    public async reconnect<RoomType extends ServerRoomLike>(\n        reconnectionToken: string,\n        rootSchema?: SchemaConstructor<RoomType['state']>\n    ): Promise<Room<RoomType, RoomType['state']>>\n    // Overload: Pass State type directly\n    public async reconnect<State = any>(\n        reconnectionToken: string,\n        rootSchema?: SchemaConstructor<State>\n    ): Promise<Room<any, State>>\n    // Implementation\n    public async reconnect<T = any>(reconnectionToken: string, rootSchema?: SchemaConstructor<T>) {\n        if (typeof (reconnectionToken) === \"string\" && typeof (rootSchema) === \"string\") {\n            throw new Error(\"DEPRECATED: .reconnect() now only accepts 'reconnectionToken' as argument.\\nYou can get this token from previously connected `room.reconnectionToken`\");\n        }\n        const [roomId, token] = reconnectionToken.split(\":\");\n\t\tif (!roomId || !token) {\n\t\t\tthrow new Error(\"Invalid reconnection token format.\\nThe format should be roomId:reconnectionToken\");\n\t\t}\n        return await this.createMatchMakeRequest<T>('reconnect', roomId, { reconnectionToken: token }, rootSchema);\n    }\n\n    public async consumeSeatReservation<T>(\n        response: ISeatReservation,\n        rootSchema?: SchemaConstructor<T>\n    ): Promise<Room<any, T>> {\n        const room = this.createRoom<T>(response.name, rootSchema);\n        room.roomId = response.roomId;\n        room.sessionId = response.sessionId;\n\n        const options: any = { sessionId: room.sessionId };\n\n        // forward \"reconnection token\" in case of reconnection.\n        if (response.reconnectionToken) {\n            options.reconnectionToken = response.reconnectionToken;\n        }\n\n        room.connect(\n            this.buildEndpoint(response, options),\n            response,\n            this.http.options.headers\n        );\n\n        return new Promise((resolve, reject) => {\n            const onError = (code, message) => reject(new ServerError(code, message));\n            room.onError.once(onError);\n\n            room['onJoin'].once(() => {\n                room.onError.remove(onError);\n                resolve(room);\n            });\n        });\n    }\n\n    /**\n     * Create a new connection with the server, and measure the latency.\n     * @param options Latency measurement options (protocol, pingCount).\n     */\n    public getLatency(options: LatencyOptions = {}): Promise<number> {\n        const protocol = options.protocol ?? \"ws\";\n        const pingCount = options.pingCount ?? 1;\n\n        return new Promise<number>((resolve, reject) => {\n            const conn = new Connection(protocol);\n            const latencies: number[] = [];\n            let pingStart = 0;\n\n            conn.events.onopen = () => {\n                pingStart = Date.now();\n                conn.send(new Uint8Array([Protocol.PING]));\n            };\n\n            conn.events.onmessage = (_: MessageEvent) => {\n                latencies.push(Date.now() - pingStart);\n\n                if (latencies.length < pingCount) {\n                    // Send another ping\n                    pingStart = Date.now();\n                    conn.send(new Uint8Array([Protocol.PING]));\n                } else {\n                    // Done, calculate average and close\n                    conn.close();\n                    const average = latencies.reduce((sum, l) => sum + l, 0) / latencies.length;\n                    resolve(average);\n                }\n            };\n\n            conn.events.onerror = (event: ErrorEvent) => {\n                reject(new ServerError(CloseCode.ABNORMAL_CLOSURE, `Failed to get latency: ${event.message}`));\n            };\n\n            conn.connect(this.getHttpEndpoint());\n        });\n    }\n\n    protected async createMatchMakeRequest<T>(\n        method: string,\n        roomName: string,\n        options: JoinOptions = {},\n        rootSchema?: SchemaConstructor<T>,\n    ) {\n        try {\n            const httpResponse = await (this.http as HTTP<any>).post(`/matchmake/${method}/${roomName}`, {\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                },\n                body: options\n            });\n\n            const response = httpResponse.data as unknown as ISeatReservation;\n\n            // forward reconnection token during \"reconnect\" methods.\n            if (method === \"reconnect\") {\n                response.reconnectionToken = options.reconnectionToken;\n            }\n\n            return await this.consumeSeatReservation<T>(response, rootSchema);\n        } catch (error) {\n            if (error instanceof ServerError) {\n                throw new MatchMakeError(error.message, error.code);\n            }\n            throw error;\n        }\n    }\n\n    protected createRoom<T>(roomName: string, rootSchema?: SchemaConstructor<T>) {\n        return new Room<any, T>(roomName, rootSchema);\n    }\n\n    protected buildEndpoint(seatReservation: ISeatReservation, options: any = {}) {\n        let protocol: string = this.settings.protocol || \"ws\";\n        let searchParams = this.settings.searchParams || \"\";\n\n        // forward authentication token\n        if (this.http.authToken) {\n            options['_authToken'] = this.http.authToken;\n        }\n\n        // append provided options\n        for (const name in options) {\n            if (!options.hasOwnProperty(name)) {\n                continue;\n            }\n            searchParams += (searchParams ? '&' : '') + `${name}=${options[name]}`;\n        }\n\n        if (protocol === \"h3\") {\n            protocol = \"http\";\n        }\n\n        let endpoint = (this.settings.secure)\n            ? `${protocol}s://`\n            : `${protocol}://`;\n\n        if (seatReservation.publicAddress) {\n            endpoint += `${seatReservation.publicAddress}`;\n\n        } else {\n            endpoint += `${this.settings.hostname}${this.getEndpointPort()}${this.settings.pathname}`;\n        }\n\n        const endpointURL = `${endpoint}/${seatReservation.processId}/${seatReservation.roomId}?${searchParams}`;\n        return (this.urlBuilder)\n            ? this.urlBuilder(new URL(endpointURL))\n            : endpointURL;\n    }\n\n    protected getHttpEndpoint(segments: string = '') {\n        const path = segments.startsWith(\"/\") ? segments : `/${segments}`;\n\n        let endpointURL = `${(this.settings.secure) ? \"https\" : \"http\"}://${this.settings.hostname}${this.getEndpointPort()}${this.settings.pathname}${path}`;\n\n        if (this.settings.searchParams) {\n            endpointURL += `?${this.settings.searchParams}`;\n        }\n\n        return (this.urlBuilder)\n            ? this.urlBuilder(new URL(endpointURL))\n            : endpointURL;\n    }\n\n    protected getEndpointPort() {\n        return (this.settings.port !== 80 && this.settings.port !== 443)\n            ? `:${this.settings.port}`\n            : \"\";\n    }\n}\n\nexport const Client = ColyseusSDK;\nexport type Client<ServerType extends SDKTypes = any, UserData = any> = InstanceType<typeof ColyseusSDK<ServerType, UserData>>;"],"names":["HTTP","Auth","discordURLBuilder","__awaiter","ServerError","Connection","Protocol","CloseCode","MatchMakeError","Room"],"mappings":"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"}