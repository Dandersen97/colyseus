import type { Router, HasRequiredKeys, Prettify, UnionToIntersection, Endpoint, HTTPMethod } from "@colyseus/better-call";
type HasRequired<T extends {
    body?: any;
    query?: any;
    params?: any;
}> = HasRequiredKeys<T["body"]> extends true ? true : HasRequiredKeys<T["query"]> extends true ? true : HasRequiredKeys<T["params"]> extends true ? true : false;
type InferContext<T> = T extends (ctx: infer Ctx) => any ? Ctx extends object ? Ctx : never : never;
type WithRequired<T, K> = T & {
    [P in K extends string ? K : never]-?: T[P extends keyof T ? P : never];
};
type WithoutServerOnly<T extends Record<string, Endpoint>> = {
    [K in keyof T]: T[K] extends Endpoint<any, infer O> ? O extends {
        metadata: {
            SERVER_ONLY: true;
        };
    } ? never : T[K] : T[K];
};
type MethodOptions<API, M extends HTTPMethod> = API extends {
    [key: string]: infer T;
} ? T extends Endpoint<any, infer O> ? O["method"] extends M ? {
    [key in T["path"]]: T;
} : O["method"] extends M[] ? M extends O["method"][number] ? {
    [key in T["path"]]: T;
} : {} : O["method"] extends "*" ? {
    [key in T["path"]]: T;
} : {} : {} : {};
export type RequiredOptionKeys<C extends {
    body?: any;
    query?: any;
    params?: any;
}> = (undefined extends C["body"] ? {} : {
    body: true;
}) & (undefined extends C["query"] ? {} : {
    query: true;
}) & (undefined extends C["params"] ? {} : {
    params: true;
});
export interface ClientOptions extends FetchRequestOptions {
    baseURL: string;
}
type CommonHeaders = {
    accept: "application/json" | "text/plain" | "application/octet-stream";
    "content-type": "application/json" | "text/plain" | "application/x-www-form-urlencoded" | "multipart/form-data" | "application/octet-stream";
    authorization: "Bearer" | "Basic";
};
type FetchRequestOptions<Body = any, Query extends Record<string, any> = any, Params extends Record<string, any> | Array<string> | undefined = any, Res = any, ExtraOptions extends Record<string, any> = {}> = Prettify<ExtraOptions & Omit<RequestInit, "body"> & {
    baseURL?: string;
    /**
     * Headers
     */
    headers?: CommonHeaders | Headers | HeadersInit;
    /**
     * Body
     */
    body?: Body;
    /**
     * Query parameters (key-value pairs)
     */
    query?: Query;
    /**
     * Dynamic parameters.
     *
     * If url is defined as /path/:id, params will be { id: string }
     */
    params?: Params;
}>;
type ResponseData<T> = {
    ok: true;
    data: T;
    error: null;
    response: Response;
    headers: Headers;
    status: number;
    statusText: string;
};
type ResponseError<E> = {
    ok: false;
    data: null;
    error: Prettify<(E extends Record<string, any> ? E : {
        message?: string;
    }) & {
        code?: string;
    }>;
    response: Response;
    headers: Headers;
    status: number;
    statusText: string;
};
export declare function isJSONSerializable(value: any): boolean;
export type ResponseType = "json" | "text" | "blob";
export declare function detectResponseType(request: Response): ResponseType;
export declare const createClient: <R extends Router | Router["endpoints"]>(baseOptions: ClientOptions) => {
    get: <OPT extends UnionToIntersection<MethodOptions<WithoutServerOnly<R extends {
        endpoints: Record<string, Endpoint>;
    } ? R["endpoints"] : R>, "GET">> extends infer T ? { [K_1 in keyof T]: T[K_1]; } : never, K extends keyof OPT, C extends InferContext<OPT[K]>>(path: K, ...options: HasRequired<C> extends true ? [WithRequired<{
        cache?: RequestCache;
        credentials?: RequestCredentials;
        headers?: HeadersInit & (HeadersInit | CommonHeaders);
        integrity?: string;
        keepalive?: boolean;
        method?: string;
        mode?: RequestMode;
        priority?: RequestPriority;
        redirect?: RequestRedirect;
        referrer?: string;
        referrerPolicy?: ReferrerPolicy;
        signal?: AbortSignal | null;
        window?: null;
        baseURL?: string;
        body?: C["body"];
        query?: C["query"];
        params?: C["params"];
    }, keyof (undefined extends C["body"] ? {} : {
        body: true;
    }) | keyof (undefined extends C["query"] ? {} : {
        query: true;
    }) | keyof (undefined extends C["params"] ? {} : {
        params: true;
    })>] : [{
        cache?: RequestCache;
        credentials?: RequestCredentials;
        headers?: HeadersInit & (HeadersInit | CommonHeaders);
        integrity?: string;
        keepalive?: boolean;
        method?: string;
        mode?: RequestMode;
        priority?: RequestPriority;
        redirect?: RequestRedirect;
        referrer?: string;
        referrerPolicy?: ReferrerPolicy;
        signal?: AbortSignal | null;
        window?: null;
        baseURL?: string;
        body?: C["body"];
        query?: C["query"];
        params?: C["params"];
    }?]) => Promise<ResponseError<unknown> | ResponseData<Awaited<ReturnType<OPT[K] extends Endpoint ? OPT[K] : never>>>>;
    post: <OPT extends UnionToIntersection<MethodOptions<WithoutServerOnly<R extends {
        endpoints: Record<string, Endpoint>;
    } ? R["endpoints"] : R>, "POST">> extends infer T ? { [K_1 in keyof T]: T[K_1]; } : never, K extends keyof OPT, C extends InferContext<OPT[K]>>(path: K, ...options: HasRequired<C> extends true ? [WithRequired<{
        cache?: RequestCache;
        credentials?: RequestCredentials;
        headers?: HeadersInit & (HeadersInit | CommonHeaders);
        integrity?: string;
        keepalive?: boolean;
        method?: string;
        mode?: RequestMode;
        priority?: RequestPriority;
        redirect?: RequestRedirect;
        referrer?: string;
        referrerPolicy?: ReferrerPolicy;
        signal?: AbortSignal | null;
        window?: null;
        baseURL?: string;
        body?: C["body"];
        query?: C["query"];
        params?: C["params"];
    }, keyof (undefined extends C["body"] ? {} : {
        body: true;
    }) | keyof (undefined extends C["query"] ? {} : {
        query: true;
    }) | keyof (undefined extends C["params"] ? {} : {
        params: true;
    })>] : [{
        cache?: RequestCache;
        credentials?: RequestCredentials;
        headers?: HeadersInit & (HeadersInit | CommonHeaders);
        integrity?: string;
        keepalive?: boolean;
        method?: string;
        mode?: RequestMode;
        priority?: RequestPriority;
        redirect?: RequestRedirect;
        referrer?: string;
        referrerPolicy?: ReferrerPolicy;
        signal?: AbortSignal | null;
        window?: null;
        baseURL?: string;
        body?: C["body"];
        query?: C["query"];
        params?: C["params"];
    }?]) => Promise<ResponseError<unknown> | ResponseData<Awaited<ReturnType<OPT[K] extends Endpoint ? OPT[K] : never>>>>;
    delete: <OPT extends UnionToIntersection<MethodOptions<WithoutServerOnly<R extends {
        endpoints: Record<string, Endpoint>;
    } ? R["endpoints"] : R>, "DELETE">> extends infer T ? { [K_1 in keyof T]: T[K_1]; } : never, K extends keyof OPT, C extends InferContext<OPT[K]>>(path: K, ...options: HasRequired<C> extends true ? [WithRequired<{
        cache?: RequestCache;
        credentials?: RequestCredentials;
        headers?: HeadersInit & (HeadersInit | CommonHeaders);
        integrity?: string;
        keepalive?: boolean;
        method?: string;
        mode?: RequestMode;
        priority?: RequestPriority;
        redirect?: RequestRedirect;
        referrer?: string;
        referrerPolicy?: ReferrerPolicy;
        signal?: AbortSignal | null;
        window?: null;
        baseURL?: string;
        body?: C["body"];
        query?: C["query"];
        params?: C["params"];
    }, keyof (undefined extends C["body"] ? {} : {
        body: true;
    }) | keyof (undefined extends C["query"] ? {} : {
        query: true;
    }) | keyof (undefined extends C["params"] ? {} : {
        params: true;
    })>] : [{
        cache?: RequestCache;
        credentials?: RequestCredentials;
        headers?: HeadersInit & (HeadersInit | CommonHeaders);
        integrity?: string;
        keepalive?: boolean;
        method?: string;
        mode?: RequestMode;
        priority?: RequestPriority;
        redirect?: RequestRedirect;
        referrer?: string;
        referrerPolicy?: ReferrerPolicy;
        signal?: AbortSignal | null;
        window?: null;
        baseURL?: string;
        body?: C["body"];
        query?: C["query"];
        params?: C["params"];
    }?]) => Promise<ResponseError<unknown> | ResponseData<Awaited<ReturnType<OPT[K] extends Endpoint ? OPT[K] : never>>>>;
    patch: <OPT extends UnionToIntersection<MethodOptions<WithoutServerOnly<R extends {
        endpoints: Record<string, Endpoint>;
    } ? R["endpoints"] : R>, "PATCH">> extends infer T ? { [K_1 in keyof T]: T[K_1]; } : never, K extends keyof OPT, C extends InferContext<OPT[K]>>(path: K, ...options: HasRequired<C> extends true ? [WithRequired<{
        cache?: RequestCache;
        credentials?: RequestCredentials;
        headers?: HeadersInit & (HeadersInit | CommonHeaders);
        integrity?: string;
        keepalive?: boolean;
        method?: string;
        mode?: RequestMode;
        priority?: RequestPriority;
        redirect?: RequestRedirect;
        referrer?: string;
        referrerPolicy?: ReferrerPolicy;
        signal?: AbortSignal | null;
        window?: null;
        baseURL?: string;
        body?: C["body"];
        query?: C["query"];
        params?: C["params"];
    }, keyof (undefined extends C["body"] ? {} : {
        body: true;
    }) | keyof (undefined extends C["query"] ? {} : {
        query: true;
    }) | keyof (undefined extends C["params"] ? {} : {
        params: true;
    })>] : [{
        cache?: RequestCache;
        credentials?: RequestCredentials;
        headers?: HeadersInit & (HeadersInit | CommonHeaders);
        integrity?: string;
        keepalive?: boolean;
        method?: string;
        mode?: RequestMode;
        priority?: RequestPriority;
        redirect?: RequestRedirect;
        referrer?: string;
        referrerPolicy?: ReferrerPolicy;
        signal?: AbortSignal | null;
        window?: null;
        baseURL?: string;
        body?: C["body"];
        query?: C["query"];
        params?: C["params"];
    }?]) => Promise<ResponseError<unknown> | ResponseData<Awaited<ReturnType<OPT[K] extends Endpoint ? OPT[K] : never>>>>;
    put: <OPT extends UnionToIntersection<MethodOptions<WithoutServerOnly<R extends {
        endpoints: Record<string, Endpoint>;
    } ? R["endpoints"] : R>, "PUT">> extends infer T ? { [K_1 in keyof T]: T[K_1]; } : never, K extends keyof OPT, C extends InferContext<OPT[K]>>(path: K, ...options: HasRequired<C> extends true ? [WithRequired<{
        cache?: RequestCache;
        credentials?: RequestCredentials;
        headers?: HeadersInit & (HeadersInit | CommonHeaders);
        integrity?: string;
        keepalive?: boolean;
        method?: string;
        mode?: RequestMode;
        priority?: RequestPriority;
        redirect?: RequestRedirect;
        referrer?: string;
        referrerPolicy?: ReferrerPolicy;
        signal?: AbortSignal | null;
        window?: null;
        baseURL?: string;
        body?: C["body"];
        query?: C["query"];
        params?: C["params"];
    }, keyof (undefined extends C["body"] ? {} : {
        body: true;
    }) | keyof (undefined extends C["query"] ? {} : {
        query: true;
    }) | keyof (undefined extends C["params"] ? {} : {
        params: true;
    })>] : [{
        cache?: RequestCache;
        credentials?: RequestCredentials;
        headers?: HeadersInit & (HeadersInit | CommonHeaders);
        integrity?: string;
        keepalive?: boolean;
        method?: string;
        mode?: RequestMode;
        priority?: RequestPriority;
        redirect?: RequestRedirect;
        referrer?: string;
        referrerPolicy?: ReferrerPolicy;
        signal?: AbortSignal | null;
        window?: null;
        baseURL?: string;
        body?: C["body"];
        query?: C["query"];
        params?: C["params"];
    }?]) => Promise<ResponseError<unknown> | ResponseData<Awaited<ReturnType<OPT[K] extends Endpoint ? OPT[K] : never>>>>;
};
export {};
